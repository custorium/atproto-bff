package main

import (
	"bytes"
	"context"
	"crypto/rand"
	_ "embed"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"net/url"
	"strings"

	"github.com/bluesky-social/indigo/atproto/atcrypto"
	"github.com/bluesky-social/indigo/atproto/auth/oauth"
	"github.com/bluesky-social/indigo/atproto/syntax"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/go-querystring/query"
)

///////////////////////////////////////

// functions copied from indigo/atproto.oauth

func secureRandomBase64(sizeBytes uint) string {
	buf := make([]byte, sizeBytes)
	rand.Read(buf)
	return base64.RawURLEncoding.EncodeToString(buf)
}

func scopeStr(scopes []string) string {
	return strings.Join(scopes, " ")
}

// attempts to read an HTTP response body as JSON, and determine an error reason. always closes the response body
func parseAuthErrorReason(resp *http.Response, reqType string) string {
	defer resp.Body.Close()
	var errResp map[string]any
	if err := json.NewDecoder(resp.Body).Decode(&errResp); err != nil {
		slog.Warn("auth server request failed", "request", reqType, "statusCode", resp.StatusCode, "err", err)
		return "unknown"
	}
	slog.Warn("auth server request failed", "request", reqType, "statusCode", resp.StatusCode, "body", errResp)
	return fmt.Sprintf("%s", errResp["error"])
}

/////////////////////////////////////////

// The fields which are included in a PAR request. These HTTP POST bodies are form-encoded, so use URL encoding syntax, not JSON.
type PushedAuthRequest struct {
	// Client ID, aka client metadata URL
	ClientID string `url:"client_id"`

	// Random identifier for this request, generated by client
	State string `url:"state"`

	// Client-specified URL that will get redirected to by auth server at end of user auth flow
	RedirectURI string `url:"redirect_uri"`

	// Requested auth scopes, as a space-delimited list
	Scope string `url:"scope"`

	// Optional account identifier (DID or handle) to help with user account login and/or account switching
	LoginHint *string `url:"login_hint,omitempty"`

	// Optional id_token_hint
	IdTokenHint *string `url:"id_token_hint,omitempty"`

	// Optional hint to auth server of what expected auth behavior should be. Eg, 'create', 'none', 'consent', 'login', 'select_account'
	Prompt *string `url:"prompt,omitempty"`

	// Always "code"
	ResponseType string `url:"response_type"`

	// Always "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
	ClientAssertionType string `url:"client_assertion_type"`

	// Confidential client signed JWT
	ClientAssertion string `url:"client_assertion"`

	// Client-generated PKCE challenge hash, derived from random "verifier" string
	CodeChallenge string `url:"code_challenge"`

	// Almost always "S256"
	CodeChallengeMethod string `url:"code_challenge_method"`
}

func (s *Server) FedCMLogin(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	if err := r.ParseForm(); err != nil {
		http.Error(w, fmt.Errorf("parsing form data: %w", err).Error(), http.StatusBadRequest)
		return
	}

	idToken, _ := strings.CutPrefix(r.PostFormValue("idtoken"), "@")

	slog.Info("OAuthLogin", "client_id", s.OAuth.Config.ClientID, "callback_url", s.OAuth.Config.CallbackURL)

	redirectURL, err := StartFedCMAuthFlow(ctx, s.OAuth, idToken)
	if err != nil {
		var oauthErr = fmt.Errorf("OAuth login failed: %w", err).Error()
		slog.Error(oauthErr)
		tmplLogin.Execute(w, TmplData{Error: oauthErr})
		return
	}

	http.Redirect(w, r, redirectURL, http.StatusFound)
}

func StartFedCMAuthFlow(ctx context.Context, app *oauth.ClientApp, idToken string) (string, error) {

	var accountDID syntax.DID

	parser := jwt.NewParser()
	token, _, err := parser.ParseUnverified(idToken, jwt.MapClaims{})
	if err != nil {
		return "", fmt.Errorf("parsing ID token: %w", err)
	}

	authserverURL, err := token.Claims.GetIssuer()
	if err != nil {
		return "", fmt.Errorf("Get issuer from ID token:%w", err)
	}

	authserverMeta, err := app.Resolver.ResolveAuthServerMetadata(ctx, authserverURL)
	if err != nil {
		return "", fmt.Errorf("fetching auth server metadata: %w", err)
	}

	info, err := SendAuthRequest(ctx, app, authserverMeta, app.Config.Scopes, idToken)
	if err != nil {
		return "", fmt.Errorf("auth request failed: %w", err)
	}

	if accountDID != "" {
		info.AccountDID = &accountDID
	}

	// persist auth request info
	app.Store.SaveAuthRequestInfo(ctx, *info)

	params := url.Values{}
	params.Set("client_id", app.Config.ClientID)
	params.Set("request_uri", info.RequestURI)

	// AuthorizationEndpoint was already checked to be a clean URL
	// TODO: could do additional SSRF checks on the redirect domain here
	redirectURL := fmt.Sprintf("%s?%s", authserverMeta.AuthorizationEndpoint, params.Encode())
	return redirectURL, nil
}

func SendAuthRequest(ctx context.Context, app *oauth.ClientApp, authMeta *oauth.AuthServerMetadata, scopes []string, idToken string) (*oauth.AuthRequestData, error) {

	parURL := authMeta.PushedAuthorizationRequestEndpoint
	state := secureRandomBase64(16)
	pkceVerifier := secureRandomBase64(48)

	// generate PKCE code challenge for use in PAR request
	codeChallenge := oauth.S256CodeChallenge(pkceVerifier)

	slog.Debug("preparing PAR", "client_id", app.Config.ClientID, "callback_url", app.Config.CallbackURL)
	body := PushedAuthRequest{
		ClientID:            app.Config.ClientID,
		State:               state,
		RedirectURI:         app.Config.CallbackURL,
		Scope:               scopeStr(scopes),
		ResponseType:        "code",
		CodeChallenge:       codeChallenge,
		CodeChallengeMethod: "S256",
		IdTokenHint:         &idToken,
	}

	if app.Config.IsConfidential() {
		// self-signed JWT using private key in client metadata (confidential client)
		assertionJWT, err := app.Config.NewClientAssertion(authMeta.Issuer)
		if err != nil {
			return nil, err
		}
		body.ClientAssertionType = oauth.ClientAssertionJWTBearer
		body.ClientAssertion = assertionJWT
	}

	vals, err := query.Values(body)
	if err != nil {
		return nil, err
	}
	bodyBytes := []byte(vals.Encode())

	// when starting a new session, we don't know the DPoP nonce yet
	dpopServerNonce := ""

	// create new key for the session
	dpopPrivKey, err := atcrypto.GeneratePrivateKeyP256()
	if err != nil {
		return nil, err
	}

	slog.Debug("sending auth request", "scopes", scopes, "state", state, "redirectURI", app.Config.CallbackURL)

	var resp *http.Response
	for range 2 {
		dpopJWT, err := oauth.NewAuthDPoP("POST", parURL, dpopServerNonce, dpopPrivKey)
		if err != nil {
			return nil, err
		}

		req, err := http.NewRequestWithContext(ctx, "POST", parURL, bytes.NewBuffer(bodyBytes))
		if err != nil {
			return nil, err
		}
		req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
		req.Header.Set("DPoP", dpopJWT)

		resp, err = app.Client.Do(req)
		if err != nil {
			return nil, err
		}

		// update DPoP Nonce
		dpopServerNonce = resp.Header.Get("DPoP-Nonce")

		// check for an error condition caused by an out of date DPoP nonce
		// note that the HTTP status code would be 400 Bad Request on token endpoint, not 401 Unauthorized like it would be on Resource Server requests
		if resp.StatusCode == http.StatusBadRequest && dpopServerNonce != "" {
			// parseAuthErrorReason() always closes resp.Body
			reason := parseAuthErrorReason(resp, "PAR")
			if reason == "use_dpop_nonce" {
				// already updated nonce value above; loop around and try again
				continue
			}
			return nil, fmt.Errorf("PAR request failed (HTTP %d): %s", resp.StatusCode, reason)
		}

		// otherwise process result
		break
	}

	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		reason := parseAuthErrorReason(resp, "PAR")
		return nil, fmt.Errorf("PAR request failed (HTTP %d): %s", resp.StatusCode, reason)
	}

	var parResp oauth.PushedAuthResponse
	if err := json.NewDecoder(resp.Body).Decode(&parResp); err != nil {
		return nil, fmt.Errorf("auth request (PAR) response failed to decode: %w", err)
	}

	parInfo := oauth.AuthRequestData{
		State:                        state,
		AuthServerURL:                authMeta.Issuer,
		Scopes:                       scopes,
		PKCEVerifier:                 pkceVerifier,
		RequestURI:                   parResp.RequestURI,
		AuthServerTokenEndpoint:      authMeta.TokenEndpoint,
		AuthServerRevocationEndpoint: authMeta.RevocationEndpoint,
		DPoPAuthServerNonce:          dpopServerNonce,
		DPoPPrivateKeyMultibase:      dpopPrivKey.Multibase(),
	}

	return &parInfo, nil
}
